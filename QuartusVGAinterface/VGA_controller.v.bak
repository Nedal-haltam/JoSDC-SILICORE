module VGA_controller(
iRST_n,
iVGA_CLK,
oBLANK_n,
oHS,
oVS,
b_data,
g_data,
r_data,

manual_clk,
cpu_rst,
PC,
sw

							 
);

parameter addrw = 19;
parameter width = 640;
parameter height = 480;
`ifdef DE10LITE
parameter COLORW = 4;
`else
parameter COLORW = 8;
`endif

input [9:0] sw;
input manual_clk, cpu_rst;
wire [3*COLORW - 1: 0] rgb_from_cpu;
wire datasource;
output [5:0] PC;


input iRST_n;
input iVGA_CLK;
output reg oBLANK_n;
output reg oHS;
output reg oVS;
output [COLORW - 1:0] b_data;
output [COLORW - 1:0] g_data;  
output [COLORW - 1:0] r_data;                        


reg [addrw:0] tempADDRx;
reg [addrw:0] tempADDRy;
reg [addrw:0] ADDR;
wire [addrw:0] FINAL_ADDR;

reg  [3*COLORW - 1: 0] bgr_data;
wire [3*COLORW - 1: 0] bgr_data_raw;
wire cBLANK_n,cHS,cVS;

////
video_sync_generator LTM_ins (.vga_clk(iVGA_CLK),
                              .reset(~iRST_n),
                              .blank_n(cBLANK_n),
                              .HS(cHS),
                              .VS(cVS),
										.datasource(datasource));
////
////Addresss generator
always@(posedge iVGA_CLK , negedge iRST_n) 
begin

`ERROR_COND(ADDR)
else if (cBLANK_n==1'b1) begin
	ADDR <= ADDR + 1;
end  
end

always@(posedge iVGA_CLK , negedge iRST_n) begin
// ADDR = 0 -> 307200
// tempADDRx = 0 -> 127
// tempADDRy = 0 -> 95
if (!iRST_n)
begin
   tempADDRx <= 0;
   tempADDRy <= 0;
end	
else if (cHS==1'b0 && cVS==1'b0)
begin
   tempADDRx <= 0;
   tempADDRy <= 0;
end	

else if (cBLANK_n == 1'b1)
begin
  if (tempADDRx == width - 1)
  begin 
     tempADDRx <= 0;
     if (tempADDRy == height - 1)
        tempADDRy <= 0;
     else
        tempADDRy <= tempADDRy + 1;
  end
  else
     tempADDRx <= tempADDRx + 1;
end

end


assign FINAL_ADDR = (tempADDRx / `RS) + (tempADDRy / `RS)*(128);

//////////////////////////
//////INDEX addr.
// here is where our image is stored
`ifdef DE10LITE
imgde10lite img_inst(
	.address ( FINAL_ADDR ),
	.clock ( iVGA_CLK ),
	.q ( bgr_data_raw )
);
`else
img img_inst(
	.address ( FINAL_ADDR ),
	.clock ( iVGA_CLK ),
	.q ( bgr_data_raw )
);
`endif

proc_interface cpu(sw, iVGA_CLK, manual_clk, datasource, cHS, cVS, iRST_n, cpu_rst, PC, rgb_from_cpu);



//////latch valid data at falling edge;
always@(negedge iVGA_CLK) begin

if (datasource == 1'b1)
	bgr_data <= rgb_from_cpu;
else
	bgr_data <= bgr_data_raw;

end

assign r_data = (cBLANK_n == 1'b0) ? 0 : bgr_data[1*COLORW - 1: 0*COLORW];
assign g_data = (cBLANK_n == 1'b0) ? 0 : bgr_data[2*COLORW - 1: 1*COLORW];
assign b_data = (cBLANK_n == 1'b0) ? 0 : bgr_data[3*COLORW - 1: 2*COLORW];

///////////////////
//////Delay the iHD, iVD,iDEN for one clock cycle;
always@(negedge iVGA_CLK)
begin
  oHS<=cHS;
  oVS<=cVS;
  oBLANK_n<=cBLANK_n;
end

endmodule
 	
















