
module forward_unit(if_id_opcode, if_id_rs1, if_id_rs2, id_ex_opcode, id_ex_rs1, id_ex_rs2, id_ex_rd, id_ex_wr, ex_mem_rd, ex_mem_wr, mem_wb_rd, mem_wb_wr, 
					sel_target_address_adder_mux_InDecodeStage, 
					comparator_mux_selA, comparator_mux_selB, 
					forwardA, forwardB, store_rs2_forward
					);


	input [6:0] if_id_opcode, id_ex_opcode;
	input [4:0] if_id_rs1, if_id_rs2, id_ex_rs1, id_ex_rs2;				
	input [4:0] id_ex_rd, ex_mem_rd, mem_wb_rd; 
	input id_ex_wr, ex_mem_wr, mem_wb_wr;
	
	output reg [1:0] forwardA; // the selection lines for the ALU oprands mux
	output reg [2:0] forwardB; 
    output reg [1:0] store_rs2_forward;
	output reg [2:0] sel_target_address_adder_mux_InDecodeStage;
	output reg [1:0] comparator_mux_selA, comparator_mux_selB;
	
	
	always@(*) begin
	//-----------------------------------------------------------------------------------------
	// in this section of the module we forward to the ALU oprands mux for the execution haz and mem hazard if needed
	
	// for the first ALU Operand:
	if (id_ex_opcode == 7'h38) // if LUI -> operand1 = rs1 but the ALU_OP will drive the ALU to output the immed value which is in the second Operand
		forwardA <= 2'b11;
	else if (id_ex_opcode == 7'h6f || id_ex_opcode == 7'h67) // if jal or jalr -> operand1 = PC
		forwardA <= 2'b00;
    else if (ex_mem_wr && ex_mem_rd != 5'd0 && ex_mem_rd == id_ex_rs1) // if EX haz 
		forwardA <= 2'b01;// but it will come from a mux whos sel line is EX_MEM_memread. 
						   // if zero then from the buffer that is from the alu 
						   // else if one then from the mem out (same thing with rs2)
    else if (mem_wb_wr && mem_wb_rd != 5'd0 && mem_wb_rd == id_ex_rs1) // else if MEM haz
		forwardA <= 2'b10;
	else // else normal operation -> rs1 from the register file
		forwardA <= 2'b11;
    
	
	// for the second ALU Operand:
	if (id_ex_opcode == 7'h38 || id_ex_opcode == 7'h03 || id_ex_opcode == 7'h1b || id_ex_opcode == 7'h13 || id_ex_opcode == 7'h23) // if LUI or I-type or store(other than jal,jalr) -> operand2 = immed
		forwardB <= 3'b000;
	else if (id_ex_opcode == 7'h6f || id_ex_opcode == 7'h67) // if jal or jalr -> operand2 = 4
		forwardB <= 3'b001;
    else if (ex_mem_wr && ex_mem_rd != 5'd0 && ex_mem_rd == id_ex_rs2) // else if EX haz
		forwardB <= 3'b010;
    else if (mem_wb_wr && mem_wb_rd != 5'd0 && mem_wb_rd == id_ex_rs2) // else if MEM haz
		forwardB <= 3'b011;
	else // else noraml operation -> rs2 from the register file
		forwardB <= 3'b100;
      
      // here we forward the rs2 value for storing the right value in the memory
      if (ex_mem_wr && ex_mem_rd != 5'd0 && ex_mem_rd == id_ex_rs2)
        store_rs2_forward <= 2'b01;
      else if (mem_wb_wr && mem_wb_rd != 5'd0 && mem_wb_rd == id_ex_rs2)
        store_rs2_forward <= 2'b10;
      else 
        store_rs2_forward <= 2'b00;

	end
	
	
	
	always@(*) begin
	
	//-----------------------------------------------------------------------------------------
	// in this section of the module we forward the wanted register to compute the address that we want to 
	// jump to for the jalr instruction. we will forward it from the alu out 
	// or MEM stage or from the wb_mux		
	 
	if (if_id_opcode == 7'h67) begin // if the instruction is a jalr in the decode stage then we will select where to forward from
	
		if (id_ex_wr && id_ex_rd != 5'd0 && if_id_rs1 == id_ex_rd) // from the ALU out
			sel_target_address_adder_mux_InDecodeStage <= 3'b000;
			
		else if (ex_mem_wr && ex_mem_rd != 5'd0 && if_id_rs1 == ex_mem_rd) // from the MEM stage
			sel_target_address_adder_mux_InDecodeStage <= 3'b001;
			
		else if (mem_wb_wr && mem_wb_rd != 5'd0 && if_id_rs1 == mem_wb_rd) // from the wb_mux
			sel_target_address_adder_mux_InDecodeStage <= 3'b010;
			
		else 
			sel_target_address_adder_mux_InDecodeStage <= 3'b011; // or from the register file it self if there is no dependencies
			
	end else // any instruction other than jalr (e.g. branch or jal). the first Operand of the adder that will calculate the target address will be the PC not a register
			sel_target_address_adder_mux_InDecodeStage <= 3'b100;
		
	end
	
	always@(*) begin
	
	//-----------------------------------------------------------------------------------------
	// 									BRANCH FORWARDING COMPARATOR
	// in this section of the module we decide whether we forward the results that will be written on the
	// register file from the following places to the operands of the comparator
	// the places are : alu out , MEM stage , wb_mux
	// any branch instruction can use this section to decide whether to branch or not (just add the neccessary comparison)
	
	// for Operand1	
	if (id_ex_wr && id_ex_rd != 5'd0 && if_id_rs1 == id_ex_rd)
		comparator_mux_selA <= 2'b00;
	else if (ex_mem_wr && ex_mem_rd != 5'd0 && if_id_rs1 == ex_mem_rd)
		comparator_mux_selA <= 2'b01;
	else if (mem_wb_wr && mem_wb_rd != 5'd0 && if_id_rs1 == mem_wb_rd)
		comparator_mux_selA <= 2'b10;
	else
		comparator_mux_selA <= 2'b11;
	
	
	
	// for Operand2
	if (id_ex_wr && id_ex_rd != 5'd0 && if_id_rs2 == id_ex_rd)
		comparator_mux_selB <= 2'b00;
	else if (ex_mem_wr && ex_mem_rd != 5'd0 && if_id_rs2 == ex_mem_rd)
		comparator_mux_selB <= 2'b01;
	else if (mem_wb_wr && mem_wb_rd != 5'd0 && if_id_rs2 == mem_wb_rd)
		comparator_mux_selB <= 2'b10;
	else
		comparator_mux_selB <= 2'b11;
	
	end
	
endmodule