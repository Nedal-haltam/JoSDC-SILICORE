$date
	Wed Oct 30 22:16:43 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module RegFile_tb $end
$var wire 32 ! output_ROBEN_test [31:0] $end
$var wire 32 " RP1_Reg2 [31:0] $end
$var wire 32 # RP1_Reg1 [31:0] $end
$var parameter 32 $ ROB_Entry_WIDTH $end
$var reg 5 % RP1_index1 [4:0] $end
$var reg 5 & RP1_index2 [4:0] $end
$var reg 5 ' WP1_DRindex [4:0] $end
$var reg 5 ( WP1_DRindex_IQ [4:0] $end
$var reg 32 ) WP1_Data [31:0] $end
$var reg 5 * WP1_ROBEN [4:0] $end
$var reg 5 + WP1_ROBEN_IQ [4:0] $end
$var reg 1 , WP1_Wen $end
$var reg 1 - WP1_Wen_IQ $end
$var reg 1 . clk $end
$var reg 5 / input_WP1_DRindex_test [4:0] $end
$var reg 8193 0 msg_ROB_read [8192:0] $end
$var reg 8193 1 msg_RP1_Reg1 [8192:0] $end
$var reg 1 2 rst $end
$var reg 8193 3 temp [8192:0] $end
$var integer 32 4 i [31:0] $end
$scope module dut $end
$var wire 32 5 RP1_Reg1 [31:0] $end
$var wire 32 6 RP1_Reg2 [31:0] $end
$var wire 5 7 RP1_index1 [4:0] $end
$var wire 5 8 RP1_index2 [4:0] $end
$var wire 5 9 WP1_DRindex [4:0] $end
$var wire 5 : WP1_DRindex_IQ [4:0] $end
$var wire 32 ; WP1_Data [31:0] $end
$var wire 5 < WP1_ROBEN [4:0] $end
$var wire 5 = WP1_ROBEN_IQ [4:0] $end
$var wire 1 , WP1_Wen $end
$var wire 1 - WP1_Wen_IQ $end
$var wire 1 . clk $end
$var wire 5 > input_WP1_DRindex_test [4:0] $end
$var wire 32 ? output_ROBEN_test [31:0] $end
$var wire 1 2 rst $end
$var parameter 32 @ ROB_Entry_WIDTH $end
$var integer 32 A i [31:0] $end
$var integer 32 B j [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b101 @
b101 $
$end
#0
$dumpvars
b100000 B
b100000 A
bx ?
bx >
b0 =
b0 <
bx ;
b0 :
b0 9
bx 8
bx 7
bx 6
bx 5
bx 4
b0 3
12
b1010010010100000011000101011111011010010110111001100100011001010111100000110001001000000011110100100000001001010110010000100000001011000010000001010010010100000011000101011111010100100110010101100111001100010010000000111101001000000010010101100100 1
b101011101010000001100010101111101000100010100100110100101101110011001000110010101111000010111110100100101010001001000000011110100100000001001010110010000100000001011000010000001101111011101010111010001110000011101010111010001011111010100100100111101000010010001010100111001011111011101000110010101110011011101000010000000111101001000000010010101100100 0
bx /
1.
0-
0,
b0 +
b0 *
bx )
b0 (
b0 '
bx &
bx %
bx #
bx "
bx !
$end
#1
b100000 B
0.
#2
1.
b1 (
b1 :
b10 +
b10 =
1-
b10 *
b10 <
b1 '
b1 9
b1111011 )
b1111011 ;
1,
b0 !
b0 ?
b1001 /
b1001 >
b1010111010100000011000101011111010001000101001001101001011011100110010001100101011110000101111101001001010100010010000000111101001000000010000000111001001000000010110000100000011011110111010101110100011100000111010101110100010111110101001001001111010000100100010101001110010111110111010001100101011100110111010000100000001111010010000000100000001000000010000000100000001000000010000000100000001000000010000000110000 3
b0 #
b0 5
b1001 %
b1001 7
b1010 4
02
#3
0.
#4
1.
b0 !
b0 ?
b1001 /
b1001 >
b1010111010100000011000101011111010001000101001001101001011011100110010001100101011110000101111101001001010100010010000000111101001000000010000000111001001000000010110000100000011011110111010101110100011100000111010101110100010111110101001001001111010000100100010101001110010111110111010001100101011100110111010000100000001111010010000000100000001000000010000000100000001000000010000000100000001000000010000000110000 3
b1001 %
b1001 7
b1010 4
#5
0.
#6
1.
b0 !
b0 ?
b1001 /
b1001 >
b0 #
b0 5
b1010111010100000011000101011111010001000101001001101001011011100110010001100101011110000101111101001001010100010010000000111101001000000010000000111001001000000010110000100000011011110111010101110100011100000111010101110100010111110101001001001111010000100100010101001110010111110111010001100101011100110111010000100000001111010010000000100000001000000010000000100000001000000010000000100000001000000010000000110000 3
b1001 %
b1001 7
b1010 4
